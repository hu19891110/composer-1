<!DOCTYPE html>
<html>
  <head>
    <title>Composer</title>
    <style>
      body { margin:0px; padding:0px; background: #000;}
      @font-face {
        font-family: "ProggyClean";
        src: url('fonts/ProggyClean.ttf');
      }
    </style>
    <script type="text/javascript" src="../carena/lib/carena.js"></script>
    <script type="text/javascript" src="lib/composer.js"></script>
    <script type="text/javascript" src="../cider/lib/cider.js"></script>

    <script src="lib/jquery.js"></script>
    <script type="text/javascript">
      jQuery(function() {
        var feature  = carena.feature,
            defaultFont = "16px ProggyClean",
            renderer = carena.build({}, ["carena.Renderer"], {
              canvas: document.getElementById("composer"),
              style: {
                backgroundColor : "rgb(0,0,0)"
              }
            }),
            camera = carena.build({},
              [
                "carena.Eventable",
                "carena.Camera",
                "carena.DragManager",
                "carena.DropManager"
              ], {
              renderer: renderer
            }),
            scene;

        var createNode = function(nodeId, nodeObj, fn) {
          $.ajax({
            url     : '/nodes/' + nodeObj.name,
            dataType: 'json',
            success : function(data) {
              nodeObj.options.width  = 100;
              nodeObj.options.height = 100;
              var node  = carena.build(nodeObj.options || {}, [
                    "carena.Node",
                    "carena.Renderable",
                    "composer.Functional",
                    "carena.Draggable",
                    "carena.RelativeToParent",
                    "carena.Box"
                  ], {
                    myId: nodeId
                  }),
                  // Build the label
                  label = carena.build({
                    color: "white",
                    style: {
                      backgroundColor: "black"
                    },
                    width: node.width,
                    height: 20,
                    x: node.x,
                    y: node.y,
                    text: nodeObj.name
                  }, [
                    "cider.Textual",
                    "carena.RelativeToParent"
                  ]);

              label.font.set(defaultFont);
              label.style.paddingLeft = 5;
              label.style.paddingTop = 0;
              node.add(label);
              
              // build out ports
              for (var i=0; i<data.ports['out'].length; i++) {
                node.add(carena.build({
                  x: node.x + (i*22),
                  y: node.y + node.height,
                  width: 20,
                  height:10,
                  style : {
                    backgroundColor: "green"
                  },
                  port : data.ports['out'][i]
                }, [
                  "carena.RelativeToParent", "composer.Port"
                ]));
              }

              for (var j=0; j<data.ports['in'].length; j++) {
                node.add(carena.build({
                  x: node.x + (j*22),
                  y: node.y - 10,
                  width: 20,
                  height:10,
                  style : {
                    backgroundColor : "red"
                  },
                  port : data.ports['in'][i]
                }, [
                  "carena.RelativeToParent", "composer.Port"
                ]));
              }

              fn(null, node);
            }
          });
        };
        
        var fromTransport = function(obj) {

          var flow = carena.build({
            x     : 0,
            y     : 0,
            width : 100,
            height: 100,
            color : 'darkgrey'},
          [
            "carena.Node",
            "carena.Eventable",
            "carena.Draggable",
            "carena.RelativeToParent",
          ]);

          // Recreate the nodes
          if (obj.nodes) {
            var nodeCount = 0, idMap = {};
            for (var nodeId in obj.nodes) {
              if (obj.nodes.hasOwnProperty(nodeId)) {
                nodeCount++;
                createNode(nodeId, obj.nodes[nodeId], function(err, node) {
                  nodeCount--;
                  if (err) {
                    console.log(err);
                    return;
                  }
                  // TODO: keep the id map in carena
                  idMap[node.myId] = node;
                  flow.add(node);

                  if (nodeCount <= 0 && obj.pipes) {
                    for (var pipeIdx in obj.pipes) {
                      if (obj.pipes.hasOwnProperty(pipeIdx)) {
                       var pipeObj = carena.build({},['composer.Pipe']);
                       var pipe = obj.pipes[pipeIdx];
                       var sourcePorts = idMap[pipe.source.id].ports;
                       var targetPorts = idMap[pipe.target.id].ports;
                       var port;

                       for (var i=0; i<sourcePorts.length; i++) {
                        port = sourcePorts[i];

                        if (port.direction === pipe.source.port[0] &&
                            port.portIndex === pipe.source.port[1])
                        {
                          pipeObj.source = port;
                          break;
                        }
                       }

                       for (var i=0; i<targetPorts.length; i++) {
                        port = targetPorts[i];
                        console.log(port.direction);
                        if (port.direction === pipe.target.port[0] &&
                            port.portIndex === pipe.target.port[1])
                        {
                          console.log("setup target");
                          pipeObj.target = port;
                          
                          // parent the pipe so it will get rendered
                          var source = pipeObj.source, target = pipeObj.target;
                          var commonParent = carena.commonAncestor(source,
                                                                   target);
                          if (commonParent) {
                            commonParent.unshift(pipeObj);
                          }
                          break;
                        }
                       }
                      }
                    }
                  }
                });
              }
            }
          }

/*

          function recurse(node, data) {
            if (data.children && data.children.length > 0) {
              for (var nodeIdx = 0; nodeIdx<data.children.length; nodeIdx++) {
                // build an array of node features
                var current = data.children[nodeIdx];
                current.settings = current.settings || {
                  color : "white",
                  x:50,
                  y:50,
                  width: 100,
                  height:100
                };
                var built = carena.build(current.settings, current.features, current.settings);
                if (built.font) {
                  built.font.set(defaultFont);
                }
                node.add(recurse(built, current));
              }
            }
            return node;
          }
          if (obj.scene) {
            if (!obj.scene.children && obj.scene.length) {
              return recurse(flow, { children: obj.scene });
            } else {
              return recurse(flow, obj.scene);
            }
          } else {
            return flow;
          }*/
          return flow;
        };


/*
Target format:

{
  type: "flow",
  name : "THEFLOW",
  nodes: {
    "c4c9366c" : {
      type : "js",
      name : "hello",
      options : {
        x     :10,
        y     :100,
        style : {
           backgroundColor : "#FF00FF"
        }
      }
    },
    "dcf12f26" : {
      type    : "js",
      name    : "out",
      options : {
        x : 10,
        y: 500,
        style : {
          backgroundColor: "#FF000"
        }
      }
    }
  },
  pipes : [
    {
      source : {
        id   : "c4c9366c",
        port : ["out", "return"]
      },
      target : {
        id   : "dcf12f26",
        port : ["in", "data"]
      }
    }
  ]
}

*/

        var toTransport = window.toTransport = function(branch) {
          var res = {
            type : "flow",
            name : "THEFLOW",
          },
          nodes = {},
          pipes = [],
          recurse = function(node) {
            if (node.hasFeature("composer.Functional") && node.parent === branch) {
              nodes[node.myId] = {
                type    : node.type,
                name    : node.name || node.myId,
                options : {
                  x : node.x,
                  y : node.y,
                  style : {
                    backgroundColor : node.style.backgroundColor
                  }
                }
              };
            } else if (node.hasFeature("composer.Pipe")) {
              pipes.push({
                source : {
                  id   : node.source.parent.myId,
                  port : [node.source.direction, node.source.name]
                },
                target : {
                  id   : node.target.parent.myId,
                  port : [node.target.direction, node.target.name]
                }
              });
            }

            if (node.children && node.children.length) {
              for (var i = 0; i<node.children.length; i++) {
                recurse(node.children[i]);
              }
            }
          };
          recurse(branch);
          res.nodes = nodes;
          res.pipes = pipes;
          return res;
        };

        var saving = false;
        function save() {
          if (!saving) {
            saving = true;
            jQuery.ajax({
              type : "post",
              url  : "/nodes/",
              data : JSON.stringify(toTransport(scene)),
              contentType : "application/json",
              complete : function(data) {
                saving = false;
              }
            });
          }
        }
        var selected = null;
        jQuery.ajax({
          url : "/nodes/THEFLOW",
          dataType: "json",
          success : function(data) {
            scene = fromTransport(data);
            window.scene = scene;
            scene.width=0;
            scene.height=0;
            scene.containsPoint = function() { return true; }
          },
          error : function() {
            // Create THEFLOW
            jQuery.ajax({
              type : "post",
              url  : "/nodes/",
              data : { name: "THEFLOW", type: "flow" },
              success  : function() {
                window.location.reload();
              }

            });
          },
          complete: function() {
            scene.event.bind("node.dirty", save);
            scene.event.bind("mouse.down", function(name, data) {
              selected = data.target;
            });

            // TODO: woah, this is a global handler. is this a good thing?
            scene.event.bind("mouse.click.2", function(name,data) {
              // double click
              for (var i=0; i<data.target.features.length; i++) {
                if (data.target.features[i] === "composer.Functional") {
                  jQuery.ajax({
                    url      : data.target.code,
                    dataType : "json",
                    success  : function(codeObj) {
                      spawnEditor(true, codeObj.name, codeObj.code);
                    }
                  });
                  break;
                }
              }
            });
            camera.target = scene;

            scene.dirty = true;
            setTimeout(function render() {
              var ctx = renderer.context;
              if (ctx.canvas.width !== $(window).width() ||
                  ctx.canvas.height != $(window).height()-5)
              {
                ctx.canvas.width =  $(window).width();
                ctx.canvas.height = $(window).height()-5;
              }
              camera.render();
              setTimeout(render, 1000/40);
            }, 0);
          }
        })

        var chooser = null,
            editorWindow = false;


        document.addEventListener("keydown", function(ev) {
          if (ev.keyCode === 8) { // backspace
            ev.preventDefault();
            ev.stopPropagation();

            if (selected && selected.parent) {
              var parent = selected.parent;
              selected.parent.remove(selected);
              selected = parent.child(0);
            }
          } else if (ev.keyCode === 27) { // escape
            if (chooser !== null && chooser.x) {
              chooser.parent.remove(chooser);
              chooser = null;
            } else if (editorWindow) {
              editorWindow.parent.remove(editorWindow);
              for (var i=0; i<editorWindow.children.length; i++) {
                editorWindow.children[i].parent = null;
              }
              editorWindow = false;
            }
          } else if (ev.keyCode === 32) {
            // Spawn a dialog for choosing a node from the db
            if (!chooser && !editorWindow) {
              chooser = true;
              jQuery.ajax({
                url: "/nodes",
                dataType: "json",
                success: function(data) {

                  var keys = Object.keys(data), l = keys.length, h = 30, w = 300;
                  chooser = carena.build({
                    x: 10,
                    y: 10,
                    height: (h*l)+l+1,
                    width: w,
                    color: "darkgrey"
                  },[
                    "carena.Node"
                  ]);

                  camera.add(chooser);

                  var buildSelectionNode = function(item) {
                    var tmp = carena.build({
                      y: chooser.y + 1+(i*h)+(i*1),
                      x: chooser.x + 10,
                      width: chooser.width-20,
                      height: h,
                      background: "black",
                      color: "white",
                      code: item.code || "",
                      name: item.name || ""
                    }, [
                      "carena.Node",
                      "carena.Eventable",
                      "composer.Functional",
                      "cider.Textual"
                    ]);
                    tmp.font.set(defaultFont);
                    tmp.event.bind("mouse.in", function() {
                      tmp.background = "#222";
                    });

                    tmp.event.bind("mouse.out", function() {
                      tmp.background = "black";
                    });

                    tmp.event.bind("mouse.click.2", function() {
                      chooser.parent.remove(chooser);
                      chooser = null;
                      spawnEditor(false, item.name, item.code);
                    });
                    tmp.event.bind("mouse.click", function(name) {
                      // Build a real node.
                      var rnd = carena.build({x:20, y: 20, width: 100, height:100,
                        code : window.location + "nodes/" + item.name,
                        name : item.name || "",
                        style : {
                          backgroundColor: "rgb(" + (new Date()).getTime()%255 +
                               ", 128," + Math.round(Math.random()*200%255) + ")",
                        }
                      }, [
                        "carena.Box",
                        "carena.Draggable",
                        "carena.RelativeToParent",
                        "composer.Functional"
                      ],{});

                      var label = carena.build({
                        x: rnd.x,
                        y:rnd.y,
                        width:rnd.width,
                        height: 20,
                        color: "white",
                        text: item.name
                      },[
                        "carena.Node",
                        "cider.Textual",
                        "carena.RelativeToParent"
                      ]);
                      label.font.set(defaultFont);
                      label.style.paddingLeft = 2;
                      label.style.paddingTop = 2;

                      for (var i=0; i<item.ports['out'].length; i++) {

                        rnd.add(carena.build({
                          x: rnd.x + (i*22),
                          y: rnd.y + rnd.height,
                          width: 20,
                          height:10,
                          style : {
                            backgroundColor: "green"
                          },
                          port : item.ports['out'][i]
                        }, [
                          "carena.RelativeToParent", "composer.Port"
                        ]));
                      }

                      for (var j=0; j<item.ports['in'].length; j++) {
                        rnd.add(carena.build({
                          x: rnd.x + (j*22),
                          y: rnd.y - 10,
                          width: 20,
                          height:10,
                          style : {
                            backgroundColor : "red"
                          },
                          port : item.ports['in'][i]
                        }, [
                          "carena.RelativeToParent", "composer.Port"
                        ]));
                      }

                      camera.target.add(rnd.add(label));
                      if (chooser.parent) {
                        chooser.parent.remove(chooser);
                      }
                      chooser = null;
                    });

                    tmp.style.paddingLeft = 10;
                    tmp.style.paddingTop  = 6;
                    tmp.fromString(item.name);
                    return tmp;
                  }

                  for (var i=0; i<l; i++) {
                    chooser.add(buildSelectionNode(data[keys[i]]));
                  }
                }
              });
            }
          } else if (ev.keyCode === 78 && ev.ctrlKey === true) {
            ev.preventDefault();
            ev.stopPropagation();
            spawnEditor(true, "", "");
          }
        }, true);


        function spawnEditor(newNode, nodeName, nodeCode) {
          // allow only one editor at a time
          if (editorWindow) {
            editorWindow.parent.remove(editorWindow);
            name.parent === null;
            editor.parent === null;
            editorWindow = false;
          }

          // spawn a new carena
          editorWindow = carena.build({
            style : {
              backgroundColor: "blue",
            },
            x:100, y: 100,
            height: 310,
            width: 400
          },[
            "carena.Node",
            "carena.Draggable"
          ]);

          var editor = carena.build({
            x:110,y:140, width: 380, height: 260
          }, [
            "carena.Node",
            "carena.RelativeToParent",
            "cider.Textual",
            "cider.Editable",
            "cider.FocusTarget"
          ]),
          lineNumbers = carena.build({},[
            "cider.LineNumbers",
            "carena.RelativeToParent"
          ]),
          name = carena.build({
            x:110,
            y:110,
            width: 270,
            height: 20
          },[
            "carena.Node",
            "carena.RelativeToParent",
            "cider.Textual",
            "cider.Editable",
            "cider.FocusTarget"
          ]),
          saveButton = carena.build({
            width: 80,
            height: 20,
            x:410,
            y:110,
            style : {
              backgroundColor: "grey"
            }
          },[
            "carena.Box",
            "carena.Eventable",
            "carena.RelativeToParent"
          ]);

          name.style.paddingLeft = 10;
          name.fromString(nodeName);
          name.setFocus();
          name.font.set(defaultFont);
          editor.font.set(defaultFont);
          // Setup the button
          // TODO: this probably could be made easier heh.
          saveButton.event.bind("mouse.in", function() {
            saveButton.color = "orange";
            return false;
          });
          saveButton.event.bind("mouse.out", function(name, data) {
            saveButton.color = "grey";
            return false;
          });
          saveButton.render = function(renderer) {

            renderer.context.fillStyle = saveButton.color;
            renderer.context.fillRect(saveButton.x,
                                      saveButton.y,
                                      saveButton.width,
                                      saveButton.height);

            renderer.context.fillStyle = "black";
            renderer.context.fillText("save", saveButton.x+20, saveButton.y+14);
          };
          function mouseUp(evName, data) {
            if (data.target === saveButton) {
              // Save to storage

              // remove the editor
              // TODO: figure out the root cause of this
              if (!editor.parent || !name.parent || !editorWindow.parent) {
                return;
              }
              var req = {
                contentType: "application/json",
                dataType : "json",
                data : JSON.stringify({
                  name: name.toString(),
                  code: editor.toString()
                }),
                success : function() {
                  editor.parent.remove(editor);
                  name.parent.remove(name);
                  editorWindow.parent.remove(editorWindow);
                  name.parent === null;
                  editor.parent === null;
                  editorWindow = false;
                }
              };
              jQuery.ajax({

                url: "/nodes/"+name.toString(),
                success : function() { newNode = false; },
                error   : function() { newNode = true; },
                contentType : "application/json",
                dataType : 'json',
                complete : function() {
                  req.url = (newNode) ? "/nodes" : "/nodes/" + name.toString();
                  req.type = (newNode) ? "post" : "put";
                  jQuery.ajax(req);
                }
              });

              return false;
            }
          }
          saveButton.event.bind("mouse.up", mouseUp);
          editor.fromString(nodeCode);

          camera.add(editorWindow.add(editor.add(lineNumbers)).add(name).add(saveButton));
        }

        var terminal = carena.build({
          x:0,y:renderer.canvas.height-200, width: renderer.canvas.width, height: 200,
          text: document.getElementById("terminal-text").innerText
        }, [
          "carena.Node",
          "cider.Textual",
        ]);
        terminal.font.set(defaultFont);
        var _terminalRender = terminal.render;
        terminal.render = function(renderer) {
          terminal.y = renderer.canvas.height-200;
          terminal.width = renderer.canvas.width;
          _terminalRender(renderer);
        }

        camera.add(terminal);

        // Console stuff
        window.addEventListener("keydown", function(ev) {
          if (ev.keyCode === 13 && editorWindow === false) {
            terminal.fromString("> executing....");
            jQuery.get("/nodes/THEFLOW/run", function(data) {
              terminal.fromString(terminal + "\n> Results:\n\n" + data);
            });
          }
        });
      });
    </script>
  </head>
  <body>
      <canvas id="composer" width="600" height="600"></canvas>
<pre id="terminal-text" style="display:none">> spawning terminal...

  Add nodes to the scene and link them up to perform operations

  Keys:
    control+n - create a new node
    space     - add existing node
    escape    - close editor / menu
    click*2   - edit an existing node (menu or node)
    return    - execute (results are shown in the terminal)

</pre>
  </body>
</html>
